---
description: Setting up your MLOps infrastructure
---

Machine Learning in production is not just about designing and training models. 
It is a fractured space consisting of a wide variety of tasks ranging from 
experiment tracking to orchestration, from model deployment to monitoring, 
from drift detection to feature stores and much, much more than that. Even 
though there are already some seemingly well-established solutions for some 
of these tasks, it can become increasingly difficult to establish a running 
production system in a reliable and modular manner, once all these solutions 
are brought together.

This is a problem which is especially visible when switching from a research 
setting to a production setting. For instance, due to the lack of standards, 
the time and resources invested in a small PoC-like project can completely to 
waste, if the initial system can not be transferred to a production-grade 
setting.

At **ZenML**, we believe that this is one of the most important and challenging 
problems in the field of MLOps, and it can be solved with a set of standards and 
well-structured abstractions. Owing to the nature of MLOps, it is critical 
that these abstractions do not only cover concepts such as pipelines, steps and 
materializers that we covered in the starter guide but also the infrastructure 
elements that the pipelines are running on.

Taking this into consideration, we will introduce three major concepts 
that ZenML is based on: **Stacks**, **Stack Components** and **Flavors**.

## Stacks

The first concept that we will look into is the **Stack**. In ZenML, a **Stack** 
essentially represents a set of configurations for the infrastructure of your 
MLOps platform.

This is achieved by bringing together different types of **Stack Components**, 
that are responsible for specific tasks within your ML workflow. We will 
explore the concept **Stack Components** in more detail in the next section, 
however, before we get there, you can find a short list of all the stack 
component types that you can use within your stack in the table below:

| Type of Stack Component | Description                                                       |
|-------------------------|-------------------------------------------------------------------|
| **Orchestrator (req)**   | Orchestrating the runs of your pipeline                           |
| **Artifact Store (req)** | Storage for the artifacts created by your pipelines               |
| **Metadata Store (req)** | Tracking the execution of your pipelines/steps                    |
| Container Registry      | Store for your containers                                         |
| Secrets Manager         | Centralized location for the storage of your secrets              |
| Step Operator           | Execution of individual steps in specialized runtime environments |
| Model Deployer          | Services/platforms responsible for online model serving           |
| Feature Store           | Management of your data/features                                  |
| Experiment Tracker      | Tracking your ML experiments                                      |
| Alerter                 | Sending alerts through specified channels                         |

Each pipeline run that you execute with ZenML will require you to have an 
**active** stack as the components within the stack are essential to the entire 
workflow. Any ZenML repository that you created through `zenml init` comes 
with an initial active `default` stack, which features a local artifact store, 
a local metadata store, and a local orchestrator. You can see this stack if you 
execute the following command:

```shell
zenml stack list
```

If you would like to work with a different stack, you can register another 
one through our CLI. Keep in mind, that establishing a stack will require you 
to specify at least of an orchestrator, an artifact store, and a metadata store. 
The rest of the stack components are optional, and you can use them as you 
see fit.

```shell
zenml stack register STACK_NAME -o <name-of-your-orchestrator> \
                                -a <name-of-your-artifact-store> \
                                -m <name-of-your-metadata-store> \
                                ...
```

Once you registered your stack, you can activate it with:

```shell
zenml stack set <name-of-your-stack>
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you easily manage/use your 
stacks. If you would like to learn more, please do: "`zenml stack --help`"
or visit our CLI docs.
{% endhint %}

## Base Abstractions

As **Stacks** represent the entire configuration of your infrastructure, **Stack
Components** represent the configuration of individual layers within your 
**Stack** which conduct specific self-contained tasks. 

For instance, each ZenML stack features an artifact store which is responsible 
for storing the artifacts generated by your pipelines, or an orchestrator 
which is responsible for the execution of the steps within your pipeline.

Programmatically, each stack component is built on top of some base 
abstractions.

```python
from abc import ABC
from pydantic import BaseModel, Field
from typing import ClassVar
from uuid import UUID, uuid4

from zenml.enums import StackComponentType

class StackComponent(BaseModel, ABC):
    """Abstract class for all components of a ZenML stack."""

    # Instance configuration
    name: str
    uuid: UUID = Field(default_factory=uuid4)

    # Class parameters
    TYPE: ClassVar[StackComponentType]
    FLAVOR: ClassVar[str]

    ...
```

There are a few things to unpack here. Let's talk about `pydantic` first. 
`pydantic` is a library for data validation and settings management. 
Using their `BaseModel` helps us to configure and serialize these components 
as we track them while allowing us to add a validation and configuration layer 
to each stack component instance/implementation.

You can already see how that comes into play here within the base 
`StackComponent` implementation. As you can see, each instance of 
a `StackComponent` needs to include a `name` and an auto-generated `uuid`. 
These variables will be tracked when we serialize the stack component object.
You can exclude an instance configuration parameter from the serialization 
by giving it a name which starts with `_`.

Moreover, you can use class variables by denoting them with the `ClassVar[..]`, 
which are also excluded from the serialization. Each `StackComponent` 
implementation features two important class variables called the `TYPE` and 
the `FLAVOR`. The `TYPE` is utilized when we set up the base implementation for 
a specific type of stack component whereas the `FLAVOR` parameter is used 
denote different flavors (which we will cover in the next section).

With these considerations, we can take a look at the `BaseArtifactStore` as an 
example:

```python
from typing import ClassVar, Set

from zenml.enums import StackComponentType
from zenml.stack import StackComponent


class BaseArtifactStore(StackComponent):
    """Abstract class for all ZenML artifact stores."""

    # Instance configuration
    path: str

    # Class parameters
    TYPE: ClassVar[StackComponentType] = StackComponentType.ARTIFACT_STORE
    SUPPORTED_SCHEMES: ClassVar[Set[str]]

    ...
```

As you can see, the `BaseArtifactStore` sets the correct `TYPE`, while 
introducing a new instance variable called `path` and class variable called 
`SUPPORTED_SCHEMES`, which will be used by all the subclasses of this base 
implementation.

TODO: Explanation about provision, deprovision, suspend and resume

## Flavors

Now, that we have taken a look at the base abstraction of stack components,
it is time to introduce the concept of **Flavors**. In ZenML, **Flavors** 
represent specific implementations over the base abstractions 
of **Stack Components**. As an example, we can take a look at the 
`LocalArtifactStore`:

```python
from typing import ClassVar, Set

from zenml.artifact_stores import BaseArtifactStore


class LocalArtifactStore(BaseArtifactStore):
    """Artifact Store for local artifacts."""

    # Class configuration
    FLAVOR: ClassVar[str] = "local"
    SUPPORTED_SCHEMES: ClassVar[Set[str]] = {""}

    ...
```

As you can see from the example below, the `LocalArtifactStore` inherits from 
the corresponding base abstraction `BaseArtifactStore` and implements a 
local version. While creating this class, it is critical to set `FLAVOR` 
class variable, as we will use it as a reference when we create an instance 
of this stack component.

Out-of-the-box, ZenML comes with a wide variety of **flavors**. This 
**flavors** are either built-in to the base ZenML package or enabled 
through the installation of specific integrations. In order to see all 
the available flavors for a specific type of stack component, you can use 
the CLI as:

```shell
zenml artifact-store flavor list
```

Through the base abstractions, ZenML also enables you to create your own 
flavors for any type of stack component. In order to achieve this, you can 
use the corresponding base abstraction, and create your own implementation, 
and register it through the CLI:

```python
from typing import ClassVar, Set

from zenml.artifact_stores import BaseArtifactStore


class MyCustomArtifactStore(BaseArtifactStore):
    """Custom artifact store implementation."""

    # Class configuration
    FLAVOR: ClassVar[str] = "custom"
    SUPPORTED_SCHEMES: ClassVar[Set[str]] = {"custom://"}

    ...
```

followed by:

```shell
zenml artifact-store flavor register path.to.MyCustomArtifacStore
```

Once you register your new flavor, you can see it in the CLI with:

```shell
zenml artifact-store flavor list
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you easily manage/use your 
flavors. If you would like to learn more, please do: 
"`zenml <stack-component-type> flavor --help`" or visit our CLI docs.
{% endhint %}

## Stack Components

Following the flavors, we can take a look at how we can actually create, use 
and manage actual stack components through the CLI. For this purpose, we can 
use the artifact stores as an example.

First, you can list the artifact store instances with:

```shell
zenml artifact-store list
```

Even when you are on a fresh start, you should see the default local 
artifact store.

If you want to create a new instance stack component of a specific flavor, you 
can use the register command:

```shell
zenml artifact-store register NAME --flavor=local --path=/path/to/your/store
```

When using the `register` command, you need to provide a `NAME` for the 
instance of the stack component, and the required instance configuration 
parameters which are defined within the corresponding flavor/abstraction 
as `--param=value`.

{% hint style="info" %}
Our CLI features a wide variety of commands that let you easily manage/use your 
flavors. If you would like to learn more, please do: 
"`zenml <stack-component-type> --help`" or visit our CLI docs.
{% endhint %}

## Configuration and usage

Configuration with instance parameters
Configuration with secrets
Configuration with runtime configs

```bash
zenml artifact-store list
```
