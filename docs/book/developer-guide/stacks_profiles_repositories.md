---
description: What are stacks, profiles, and repositories in ZenML?
---

# Stacks, Profiles, Repositories

## Stacks

Machine learning in production is not just about designing and training models. It is a fractured space consisting of a wide variety of tasks ranging from experiment tracking to orchestration, from model deployment to monitoring, from drift detection to feature stores and much, much more than that. Even though there are already some seemingly well-established solutions for these tasks, it can become increasingly difficult to establish a running production system in a reliable and modular manner once all these solutions are brought together.

This is a problem which is especially critical when switching from a research setting to a production setting. For instance, due to a lack of standards, the time and resources invested in a small PoC-like project can completely to waste, if the initial system can not be transferred to a production-grade setting.

At **ZenML**, we believe that this is one of the most important and challenging problems in the field of MLOps, and it can be solved with a set of standards and well-structured abstractions. Owing to the nature of MLOps, it is essential that these abstractions not only cover concepts such as pipelines, steps and materializers which we covered in the previous guides but also the infrastructure elements that on which the pipelines run.

Taking this into consideration, we will introduce three major concepts that ZenML is based on: **Stacks**, **Stack Components** and **Flavors**.

### Stacks

In ZenML, a **stack** essentially represents a set of configurations for the infrastructure of your MLOps platform.

This is achieved by bringing together different types of **stack components**, that are responsible for specific tasks within your ML workflow. We will look at the base abstraction for the **stack components** in more detail in the next section. However, before we get there, let's first take a look at the list of all the stack component types that you can use within your **stack** in the table below:

| **Type of Stack Component**                        | **Description**                                                   |
| -------------------------------------------------- | ----------------------------------------------------------------- |
| [**Orchestrator (required)**](../extending-zenml/orchestrators.md)     | Orchestrating the runs of your pipeline                           |
| [**Artifact Store (required)**](../extending-zenml/artifact-stores.md) | Storage for the artifacts created by your pipelines               |
| [**Metadata Store (required)**](../extending-zenml/metadata-stores.md) | Tracking the execution of your pipelines/steps                    |
| [Container Registry](../extending-zenml/container-registries.md)        | Store for your containers                                         |
| [Secrets Manager](../extending-zenml/secrets-managers.md)              | Centralized location for the storage of your secrets              |
| [Step Operator](../extending-zenml/step-operators.md)                  | Execution of individual steps in specialized runtime environments |
| [Model Deployer](../extending-zenml/model-deployers.md)                | Services/platforms responsible for online model serving           |
| [Feature Store](../extending-zenml/feature-stores.md)                  | Management of your data/features                                  |
| [Experiment Tracker](../extending-zenml/experiment-trackers.md)        | Tracking your ML experiments                                      |
| [Alerter](../extending-zenml/alerters.md)                              | Sending alerts through specified channels                         |

Keep in mind that each pipeline run that you execute with ZenML will require a **stack** and each **stack** will be required to include at least an orchestrator, an artifact store, and a metadata store. The rest of the **stack components** are optional, and you can use them as you see fit.

### Base abstractions

As **stacks** represent the entire configuration of your infrastructure, **stack components** represent the configuration of individual layers within your **stack** which conduct specific self-contained tasks. For instance, each ZenML **stack** features an artifact store which is responsible for storing the artifacts generated by your pipelines, or an orchestrator which is responsible for the execution of the steps within your pipeline.

Speaking from structural standpoint, these **stack components** are built on top of base abstractions and in their core you will find the `StackComponent` class:

```python
from abc import ABC
from pydantic import BaseModel, Field
from typing import ClassVar
from uuid import UUID, uuid4

from zenml.enums import StackComponentType

class StackComponent(BaseModel, ABC):
    """Abstract class for all components of a ZenML stack."""

    # Instance configuration
    name: str
    uuid: UUID = Field(default_factory=uuid4)

    # Class parameters
    TYPE: ClassVar[StackComponentType]
    FLAVOR: ClassVar[str]

    ...
```

There are a few things to unpack here. Let's talk about Pydantic first. Pydantic is a library for [data validation and settings management](https://pydantic-docs.helpmanual.io/). Using their `BaseModel` is helping us to configure and serialize these components while allowing us to add a validation layer to each stack component instance/implementation.

You can already see how that comes into play here within the base `StackComponent` implementation. As you can see, each instance of a `StackComponent` needs to include a `name` and an auto-generated `uuid`. These variables will be tracked when we serialize the stack component object. (You can exclude an instance configuration parameter from the serialization by giving it a name which starts with `_`.)

Moreover, you can use class variables by denoting them with the `ClassVar[..]`, which are also excluded from the serialization. Each `StackComponent` implementation features two important class variables called the `TYPE` and the `FLAVOR`. The `TYPE` is utilized when we set up the base implementation for a specific type of stack component whereas the `FLAVOR` parameter is used to denote different flavors (which we will cover in the next section).

With these considerations, we can take a look at the `BaseArtifactStore` as an example:

```python
from typing import ClassVar, Set

from zenml.enums import StackComponentType
from zenml.stack import StackComponent


class BaseArtifactStore(StackComponent):
    """Abstract class for all ZenML artifact stores."""

    # Instance configuration
    path: str

    # Class parameters
    TYPE: ClassVar[StackComponentType] = StackComponentType.ARTIFACT_STORE
    SUPPORTED_SCHEMES: ClassVar[Set[str]]

    ...
```

As you can see, the `BaseArtifactStore` sets the correct `TYPE`, while introducing a new instance variable called `path` and class variable called `SUPPORTED_SCHEMES`, which will be used by all the subclasses of this base implementation.

### Flavors

Now that we have taken a look at the base abstraction of **stack components**, it is time to introduce the concept of **flavors**. In ZenML, a **flavor** represents an implementation of a specific type of **stack component** on top of its base abstraction. As an example, we can take a look at the `LocalArtifactStore`:

```python
from typing import ClassVar, Set

from zenml.artifact_stores import BaseArtifactStore


class LocalArtifactStore(BaseArtifactStore):
    """Artifact Store for local artifacts."""

    # Class configuration
    FLAVOR: ClassVar[str] = "local"
    SUPPORTED_SCHEMES: ClassVar[Set[str]] = {""}

    ...
```

As you can see from the example above, the `LocalArtifactStore` inherits from the corresponding base abstraction `BaseArtifactStore` and implements a local version. While creating this class, it is critical to set the `FLAVOR` class variable, as we will use it as a reference when we create an instance of this stack component.

Out-of-the-box, ZenML comes with a wide variety of **flavors**. These **flavors** are either built-in to the base ZenML library or enabled through the installation of specific integrations. In order to see all the available flavors for a specific type of stack component, you can use the CLI as:

```shell
zenml artifact-store flavor list
```

Through the base abstractions, ZenML also enables you to create your own flavors for any type of stack component. In order to achieve this, you can use the corresponding base abstraction, create your own implementation, and register it through the CLI:

```python
from typing import ClassVar, Set

from zenml.artifact_stores import BaseArtifactStore


class MyCustomArtifactStore(BaseArtifactStore):
    """Custom artifact store implementation."""

    # Class configuration
    FLAVOR: ClassVar[str] = "custom"
    SUPPORTED_SCHEMES: ClassVar[Set[str]] = {"custom://"}

    ...
```

followed by:

```shell
zenml artifact-store flavor register path.to.MyCustomArtifacStore
```

Once you register your new flavor, you can see it in the CLI with:

```shell
zenml artifact-store flavor list
```

### Stack components

Following the flavors, we can take a look at how we can actually create, use and manage actual **stack components** through the CLI. For this purpose, we can keep using the artifact stores as an example.

First, you can start by listing the artifact store instances. If you are using a fresh repository, you should see the default local artifact store.

```shell
zenml artifact-store list
```

Now, if you want to create a new instance of a stack component with a specific flavor, you can use the `register` command. When using this command, you need to provide a `NAME` for the instance and the required instance configuration parameters as `--param=value`.

```shell
zenml artifact-store register NAME --flavor=local --path=/path/to/your/store
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you easily manage/use your flavors. If you would like to learn more, please do: "`zenml <stack-component-type> --help`" or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

### Bringing it together

Now that you know how to set up your stack components, let us dive into how you can use these instances to simply generate a stack:

```shell
zenml stack register STACK_NAME -o <name-of-your-orchestrator> \
                                -a <name-of-your-artifact-store> \
                                -m <name-of-your-metadata-store> \
                                ...
```

Keep in mind that any ZenML repository that you created through `zenml init` already comes with an initial active `default` stack, which features a local artifact store, a local metadata store, and a local orchestrator. You can see all of your stacks with the following command:

```shell
zenml stack list
```

As mentioned before, each pipeline run in ZenML requires an **active stack**. In order to set one of your stack as active, you can use:

```shell
zenml stack set <name-of-your-stack>
```

Once your stack is activated, you are ready to run the pipeline with the selected stack.

{% hint style="info" %}
Our CLI features a wide variety of commands that let you easily manage/use your stacks. If you would like to learn more, please do: "`zenml stack --help`" or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

### Runtime configuration

On top of the configuration through the instance parameters, you can also provide an additional runtime configuration to the stack components for your pipeline run. In order to achieve this, you need to provide these configuration parameters as key-value pairs when you run the pipeline:

```python
pipeline.run(runtime_param_1=3, another_param='luna')
```

The provided parameters will be passed to the `prepare_pipeline_deployment` method of each stack component, and you can use this method as an entrypoint to configure your stack components even further.

### Managing the state

Through a set of properties and methods, the base interface of the `StackComponent` also allows you to control the state of your stack component:

```python
from abc import ABC
from pydantic import BaseModel


class StackComponent(BaseModel, ABC):
    """Abstract class for all components of a ZenML stack."""
    ...
    
    @property
    def is_provisioned(self) -> bool:
        """If the component provisioned resources to run."""
        return True

    @property
    def is_running(self) -> bool:
        """If the component is running."""
        return True

    def provision(self) -> None:
        """Provisions resources to run the component."""

    def deprovision(self) -> None:
        """Deprovisions all resources of the component."""
        
    def resume(self) -> None:
        """Resumes the provisioned resources of the component."""

    def suspend(self) -> None:
        """Suspends the provisioned resources of the component."""

    ...
```

By default, each stack component is assumed to be in a provisioned and running state. However, if you are dealing with a component which requires you to manage its state, you can overwrite these methods. Once your implementation is complete, you can use either:

```shell
zenml stack up
```

or

```shell
zenml artifact-store up NAME
```

to provision and resume your stack component(s) and

```shell
zenml stack down 
```

or

```shell
zenml artifact-store down NAME
```

to suspend and deprovision it.

## Profiles

ZenML implicitly stores all the information about the configured Stacks, Stack
Components, and Stack Component Flavors in [a central location](../developer-guide/repo-and-config.md)
on the filesystem of the machine where it is installed. The details of how ZenML
stores this persistent data, where it is located, and how it is accessed can be
controlled through the ZenML **Profile** configuration.

Profiles are global ZenML management contexts that form the foundation of
ZenML's collaboration features. This guide walks you through the various ways in
which Profiles allow you to manage ZenML in multi-user and multi-host
use-cases of increasing complexity. Continue reading to learn more about ZenML
Profiles and how they can be configured to match your organizational needs:

* [The default Profile](#the-default-profile) comes pre-installed with ZenML
and only offers the most basic functionality.
* Create additional local Profiles to manage [multiple ZenML instances on a single host](#multi-instance-zenml).
* Use a different [store driver for your Profile](#shared-zenml-stores)
to store ZenML information in a remote shared location and make Stack
configurations available to multiple users and multiple hosts.

### The default Profile

A `default` Profile is created automatically and set as the active Profile the
first time ZenML runs on a machine:

```
$ zenml profile list
Creating default profile...
Initializing profile `default`...
Initializing store...
Registered stack component with type 'orchestrator' and name 'default'.
Registered stack component with type 'metadata_store' and name 'default'.
Registered stack component with type 'artifact_store' and name 'default'.
Registered stack with name 'default'.
Created and activated default profile.
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃   👉   │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```

Unless otherwise configured, this is the factory default ZenML setting in which
all Stacks and associated configurations are visible and shared by all ZenML
users and projects present on a machine. Configuring additional Profiles or
replacing the default Profile can unlock more possibilities for collaboration in
the context of the same host or even across multiple hosts.

### Multi-Instance ZenML

Multiple Profiles can be created on the same machine to simulate the experience
of using several independent ZenML instances completely isolated from each
other. The same or even different users can then manage their projects in the
context of different Profiles on the same host without having to worry
about overwriting each other's configuration.

To create a new local Profile, simply run `zenml profile create`:

```
$ zenml profile create zenml
Running without an active repository root.
Running with active profile: 'default' (global)
Initializing profile `zenml`...
Initializing store...
Registered stack component with type 'orchestrator' and name 'default'.
Registered stack component with type 'metadata_store' and name 'default'.
Registered stack component with type 'artifact_store' and name 'default'.
Registered stack with name 'default'.
Profile 'zenml' successfully created.

$ zenml profile list
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃   👉   │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃        │ zenml        │ local      │ file:///home/stefan/.c… │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```

A Profile can be set as the active Profile by running `zenml profile set`.
The active Profile determines the Stacks and Stack Components that are
available for use by ZenML pipelines. New Stacks and Stack Components
registered via the CLI are only added to the active Profile and are available
only as long as that Profile is active.

The following example creates a new Profile named `zenml`, sets it as active
and then shows how the `default` Profile is unaffected by the operations
performed while the `zenml` Profile is active:

```
$ zenml profile set zenml
Running without an active repository root.
Running with active profile: 'default' (global)
Active profile changed to: 'zenml'

$ zenml profile list
Running without an active repository root.
Running with active profile: 'zenml' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃        │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃   👉   │ zenml        │ local      │ file:///home/stefan/.c… │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

$ zenml stack register custom -m default -a default -o default
Running without an active repository root.
Running with active profile: 'zenml' (global)
Registered stack with name 'custom'.
Stack 'custom' successfully registered!

$ zenml stack set custom
Running without an active repository root.
Running with active profile: 'zenml' (global)
Active stack set to: 'custom'

$ zenml stack list
Running without an active repository root.
Running with active profile: 'zenml' (global)
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ custom     │ default        │ default        │ default      ┃
┃        │ default    │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

$ zenml profile list
Running without an active repository root.
Running with active profile: 'zenml' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃        │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃   👉   │ zenml        │ local      │ file:///home/stefan/.c… │ custom       ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

$ zenml profile set default
Running without an active repository root.
Running with active profile: 'zenml' (global)
Active profile changed to: 'default'

$ zenml stack list
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```

From the above example, you may have also noticed that _the active Profile_ and
_the active Stack_ are global settings that affect all other user sessions open
on the same machine. It is however possible to set the active Profile and active
Stack individually for each user session or project. Keep reading to learn more.

#### Session Level Settings with Environment Variables

The global active Profile and global active Stack can be overridden by using the
environment variables `ZENML_ACTIVATED_PROFILE` and `ZENML_ACTIVATED_STACK`,
as shown in the following example:

```
$ zenml profile list
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃   👉   │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃        │ zenml        │ local      │ file:///home/stefan/.c… │ custom       ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

$ export ZENML_ACTIVATED_PROFILE=zenml
$ export ZENML_ACTIVATED_STACK=default

$ zenml profile list
Running without an active repository root.
Running with active profile: 'zenml' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃        │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃   👉   │ zenml        │ local      │ file:///home/stefan/.c… │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

$ zenml stack list
Running without an active repository root.
Running with active profile: 'zenml' (global)
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┃        │ custom     │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```

#### Project Level Settings with ZenML Repositories

When running inside an initialized [ZenML Repository](../developer-guide/repo-and-config.md),
the active Profile and active Stack can also be configured locally,
independently of the global settings, just for that particular Repository. The
following example shows how the active Profile and active Stack can be
configured locally for a project without impacting the global settings:

```
/tmp/zenml$ zenml profile list
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃   👉   │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃        │ zenml        │ local      │ file:///home/stefan/.c… │ custom       ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml init
ZenML repository initialized at /tmp/zenml.
The local active profile was initialized to 'default' and the local active stack
to 'default'. This local configuration will only take effect when you're running
ZenML from the initialized repository root, or from a subdirectory. For more
information on profile and stack configuration, please visit https://docs.zenml.io.

/tmp/zenml$ zenml profile list
Running with active profile: 'default' (local)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃   👉   │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃        │ zenml        │ local      │ file:///home/stefan/.c… │ custom       ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml profile set zenml
Running with active profile: 'default' (local)
Active profile changed to: 'zenml'

/tmp/zenml$ zenml stack list
Running with active profile: 'zenml' (local)
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃        │ default    │ default        │ default        │ default      ┃
┃   👉   │ custom     │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml stack set default
Running with active profile: 'zenml' (local)
Active stack set to: 'default'

/tmp/zenml$ zenml stack list
Running with active profile: 'zenml' (local)
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┃        │ custom     │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ cd ..
/tmp$ zenml profile list
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME │ STORE TYPE │ URL                     │ ACTIVE STACK ┃
┠────────┼──────────────┼────────────┼─────────────────────────┼──────────────┨
┃   👉   │ default      │ local      │ file:///home/stefan/.c… │ default      ┃
┃        │ zenml        │ local      │ file:///home/stefan/.c… │ custom       ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```

Note that the Stacks and Stack Components are still stored globally, even when
running from inside a ZenML Repository. It is only the active Profile and active
Stack settings that can be configured locally.

### Migrating Stacks from Legacy Repositories to ZenML Profiles

Traditionally, Stack configurations were stored locally in the Repository root
directory - i.e. the local `.zen` folder that is created by the `zenml init`
command. The ZenML 0.7.0 release moves Stacks outside of Repository root
folders into the [global configuration directory](../developer-guide/repo-and-config.md).
The Profile concept was also introduced to replace the Repository as the
concept that manages and stores the Stack configurations.

To ensure a seamless transition from the traditional Repository root storage
to Profiles, ZenML automatically detects and migrates the Stacks from an
already initialized Repository root to a newly created Profile. This happens
automatically the first time ZenML is launched from within a legacy initialized
Repository, as demonstrated below:

```
/tmp/zenml$ zenml profile list
A legacy ZenML repository with locally configured stacks was found at 
'/tmp/zenml/.zen'.
Beginning with ZenML 0.7.0, stacks are no longer stored inside the ZenML 
repository root, they are stored globally using the newly introduced concept of
Profiles.

The stacks configured in this repository will be automatically migrated to a 
newly created profile: 'legacy-repository-b8133fe0'.

If you no longer need to use the stacks configured in this repository, please 
delete the profile using the following command:

'zenml profile delete legacy-repository-b8133fe0'

More information about Profiles can be found at https://docs.zenml.io.
This warning will not be shown again for this Repository.
Initializing profile legacy-repository-b8133fe0...
Running with active profile: 'legacy-repository-b8133fe0' (local)
┏━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ PROFILE NAME       │ STORE TYPE │ URL               │ ACTIVE STACK ┃
┠────────┼────────────────────┼────────────┼───────────────────┼──────────────┨
┃        │ default            │ local      │ file:///home/ste… │ default      ┃
┃        │ zenml              │ local      │ file:///home/ste… │ custom       ┃
┃   👉   │ legacy-repository… │ local      │ file:///tmp/zenm… │ local_stack  ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml profile describe
Running with active profile: 'legacy-repository-b8133fe0' (local)
    'legacy-repository-b8133fe0' Profile     
           Configuration (ACTIVE)            
┏━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ PROPERTY     │ VALUE                      ┃
┠──────────────┼────────────────────────────┨
┃ NAME         │ legacy-repository-b8133fe0 ┃
┠──────────────┼────────────────────────────┨
┃ STORE_URL    │ file:///tmp/zenml/.zen     ┃
┠──────────────┼────────────────────────────┨
┃ STORE_TYPE   │ local                      ┃
┠──────────────┼────────────────────────────┨
┃ ACTIVE_STACK │ local_stack                ┃
┠──────────────┼────────────────────────────┨
┃ ACTIVE_USER  │ default                    ┃
┗━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml stack list
Running with active profile: 'legacy-repository-b8133fe0' (local)
┏━━━━━━━━┯━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME      │ ARTIFACT_STORE  │ CONTAINER_REGI… │ METADATA_STORE   │ ORCHESTRATOR    ┃
┠────────┼─────────────────┼─────────────────┼─────────────────┼──────────────────┼─────────────────┨
┃        │ local_kubeflow… │ local_artifact… │ local_registry  │ local_metadata_… │ kubeflow_orche… ┃
┃   👉   │ local_stack     │ local_artifact… │                 │ local_metadata_… │ local_orchestr… ┃
┗━━━━━━━━┷━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┛
```

## Repositories

ZenML has two main locations where it stores information on the local machine.
These are the _Global Config_ 
(see [Global Configuration](../resources/global_config.md)) and the 
_Repository_. The latter is also referred to as the _.zen folder_.

The ZenML **Repository** related to a pipeline run is the folder that contains 
all the files needed to execute the run, such as the respective Python scripts
and modules where the pipeline is defined, or other associated files.
The repository plays a double role in ZenML:

* It is used by ZenML to identify which files must be copied into Docker images 
in order to execute pipeline steps remotely, e.g., when orchestrating pipelines
with [KubeFlow](../mlops_stacks/orchestrators/kubeflow.md).
* It defines the local active [Profile](#profiles) and active [Stack](#stacks)
that will be used when running pipelines from the repository root or one of its
sub-folders.

### Registering a Repository

You can register your current working directory as a ZenML
Repository by running `zenml init`, e.g.:

```shell
stefan@aspyre2:/tmp/zenml$ zenml init
ZenML repository initialized at /tmp/zenml.
```

This will create a `/tmp/zenml/.zen` directory, which contains a single
`config.yaml` file that stores the local settings:

```yaml
active_profile_name: default
active_stack_name: default
```

To unregister the repository, simply delete the `.zen` directory in the
respective location, e.g., via `rm -rf /tmp/zenml/.zen`.

{% hint style="info" %}
It is recommended to use the `zenml init` command to initialize a ZenML
_Repository_ in the same location of your custom Python source tree where you
would normally point PYTHONPATH, especially if your Python code relies on a
hierarchy of modules spread out across multiple sub-folders.

ZenML CLI commands and ZenML code will display a warning if they are not running
in the context of a ZenML _Repository_, e.g.:

```shell
stefan@aspyre2:/tmp$ zenml stack list
Unable to find ZenML repository in your current working directory (/tmp) or any parent directories. If you want to use an existing repository which is in a different location, set the environment variable 'ZENML_REPOSITORY_PATH'. If you want to create a new repository, run zenml init.
Running without an active repository root.
Running with active profile: 'default' (global)
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```
{% endhint %}

## Managing stacks in Python via the Repository

You can access your repository in Python using the `zenml.repository.Repository`
class:

```python
from zenml.repository import Repository


repo = Repository()
```

This allows you to access and manage your stack and stack components from
within Python:

### Accessing the Active Stack

The following code snippet shows how you can retrieve or modify information
of your stack and stack components in Python:

```python
from zenml.repository import Repository


repo = Repository()
active_stack = repo.active_stack
print(active_stack.name)
print(active_stack.orchestrator.name)
print(active_stack.artifact_store.name)
print(active_stack.artifact_store.path)
print(active_stack.metadata_store.name)
print(active_stack.metadata_store.uri)
```

### Registering and Changing Stacks

In the following we use the repository to register a new ZenML stack called
`local` and to set it as the active stack of the repository:

```python
from zenml.repository import Repository
from zenml.artifact_stores import LocalArtifactStore
from zenml.metadata_stores import SQLiteMetadataStore
from zenml.orchestrators import LocalOrchestrator
from zenml.stack import Stack


repo = Repository()

# Create a new orchestrator
orchestrator = LocalOrchestrator(name="local")

# Create a new metadata store
metadata_store = SQLiteMetadataStore(
    name="local",
    uri="/tmp/zenml/zenml.db",
)

# Create a new artifact store
artifact_store = LocalArtifactStore(
    name="local",
    path="/tmp/zenml/artifacts",
)

# Create a new stack with the new components
stack = Stack(
    name="local",
    orchestrator=orchestrator,
    metadata_store=metadata_store,
    artifact_store=artifact_store,
)

# Register the new stack in the currently active profile
repo.register_stack(stack)

# Set the stack as the active stack of the repository
repo.activate_stack(stack.name)
```

To explore all possible operations that can be performed via the
`Repository`, please consult the API docs section on
[Repository](https://apidocs.zenml.io/latest/api_docs/repository/#zenml.repository.Repository).
