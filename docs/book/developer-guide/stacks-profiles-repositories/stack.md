---
description: How to configure MLOps tooling and infrastructure with ZenML Stacks
---

In ZenML, a **Stack** represents a set of configurations for your MLOps tools
and infrastructure. For instance, you might want to:

- Orchestrate your ML workflows with [Kubeflow](../mlops_stacks/orchestrators/kubeflow.md),
- Save ML artifacts in an [Amazon S3](../mlops_stacks/artifact_stores/amazon_s3.md) bucket,
- Track ML metadata in a managed [MySQL](../mlops_stacks/metadata_stores/mysql.md) database,
- Monitor your models for data drift using [Evidently](../mlops_stacks/data_validators/evidently.md).

Any such combination of tools and infrastructure can be registered as a 
separate stack in ZenML. Since ZenML code is tooling-independent, you can 
switch between stacks with a single command and then automatically execute your
ML workflows on the desired stack without having to modify your code.

## Stack Components

In ZenML, each MLOps tool is associated to a specific **Stack Component**,
which is responsible for one specific task of your ML workflow. 

For instance,
each ZenML stack features an *Artifact Store* which is responsible for storing
the artifacts generated by your pipelines, and an *Orchestrator* which is
responsible for the execution of the steps within your pipeline. 

## Stack Component Flavors

The specific tool you are using is called a **Flavor** of the stack component. 
E.g., *Kubeflow* is a flavor of the *Orchestrator* stack component.

Out-of-the-box, ZenML already comes with a wide variety of flavors, which are
either built-in or enabled through the installation of specific
[Integrations](../../mlops_stacks/integrations.md).
For a detailed overview of all stack components and available flavors, 
check out the [MLOps Stacks](../mlops_stacks/categories.md) docs chapter.

## The default Stack

By default, ZenML itself and every [Repository](#repositories) that you create
already come with an initial active `default` stack, which features a local 
artifact store, a local metadata store, and a local orchestrator. 

If you followed the code examples in the 
[Steps and Pipelines](steps-and-pipelines.md) section, then you have already
used this stack implicitly to run all of your pipelines.

## Listing Stacks, Stack Components, and Flavors

You can see a list of all your *registered* stacks with the following command:

```shell
zenml stack list
```

Similarly, you can see all *registered* stack components of a specific type using:

```shell
zenml <STACK_COMPONENT> list
```

In order to see all the *available* flavors for a specific stack component, use:

```shell
zenml <STACK_COMPONENT> flavor list
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you manage and use your stacks.
If you would like to learn more, please run: "`zenml stack --help`"
or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

## Registering New Stacks

You can combine various MLOps tools into a ZenML stack as follows:

1. [Register a stack component](#registering-stack-components) for each tool 
using `zenml <STACK_COMPONENT> register`,
2. [Register a stack](#registering-a-stack) to bring all tools together using
`zenml stack register`,
3. [Activate the stack](#activating-a-stack) using `zenml stack set`. Now all
your code is automatically executed using the desired tools / infrastructure.

### Registering Stack Components

First, you need to create a new instance of the respective stack component
with the desired flavor using `zenml <STACK_COMPONENT> register <NAME> --flavor=<FLAVOR>`. 
Most flavors require further parameters that you can pass as additional
arguments `--param=value`, similar to how we passed the flavor.

E.g., to register a *local* artifact store, we could use the following command:

```shell
zenml artifact-store register <ARTIFACT_STORE_NAME> \
    --flavor=local \
    --path=/path/to/your/store
```

Afterwards, you should be able to see the new artifact store in the
list of registered artifact stores, which you can access using the following command:

```shell
zenml artifact-store list
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you manage and use your
stack components and flavors. If you would like to learn more, please run
`zenml <STACK_COMPONENT> --help` or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

### Registering a Stack

After registering each tool as the respective stack component, you can combine
all of them into one stack using the `zenml stack register` command:

```shell
zenml stack register <STACK_NAME> \
    --orchestrator <ORCHESTRATOR_NAME> \
    --artifact-store <ARTIFACT_STORE_NAME> \
    --metadata-store <METADATA_STORE_NAME> \
    ...
```

{% hint style="info" %}
You can use `zenml stack register --help` to see a list of all possible 
arguments to the `zenml stack register` command, including a list of which 
option to use for which stack component.
{% endhint %}

### Activating a Stack

Finally, to start using the stack you just registered, set it as active:

```shell
zenml stack set <STACK_NAME>
```
Now all your code is automatically executed using this stack.

{% hint style="info" %}
Some advanced stack component flavors might require connecting to remote 
infrastructure components prior to running code on the stack. This can be done
using `zenml stack up`. See the [Managing Stack States](stack-state-management.md)
section for more details.
{% endhint %}

## Changing Stacks

If you have multiple stacks configured, you can switch between them using the
`zenml stack set` command, similar to how you [activate a stack](#activating-a-stack).

## Unregistering Stacks

To unregister (delete) a stack and all of its components, run

```shell
zenml stack delete <STACK_NAME>
```

to delete the stack itself, followed by

```shell
zenml <STACK_COMPONENT> delete <STACK_COMPONENT_NAME>
```

to delete each of the individual stack components.

{% hint style="warning" %}
If you provisioned infrastructure related to the stack, make sure to
deprovision it using `zenml stack down --force` before unregistering the stack.
See the [Managing Stack States](stack-state-management.md) section for more details.
{% endhint %}
