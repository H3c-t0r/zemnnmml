---
description: How to use MLOps tools and infrastructure with stacks
---

# Understand your stack

* [ ] Shorter introduction?
* [ ] Link to all the different types of stack components here?

Machine learning in production is not just about designing and training models. It is a fractured space consisting of a wide variety of tasks ranging from experiment tracking to orchestration, from model deployment to monitoring, from drift detection to feature stores, and much, much more than that. Even though there are already some seemingly well-established solutions for these tasks, it can become increasingly difficult to establish a running production system in a reliable and modular manner once all these solutions are brought together.

This is a problem that is especially critical when switching from a research setting to a production setting. Due to a lack of standards, the time and resources invested in proof of concepts frequently go completely to waste, because the initial system can not easily be transferred to a production-grade setting.

At **ZenML**, we believe that this is one of the most important and challenging problems in the field of MLOps, and it can be solved with a set of standards and well-structured abstractions. Owing to the nature of MLOps, it is essential that these abstractions not only cover concepts such as pipelines and steps but also the infrastructure elements on which the pipelines run.

Taking this into consideration, ZenML provides additional abstractions that help you simplify infrastructure configuration and management:

* [Stacks](using-and-switching-stacks.md#stack): A combination of various MLOps _stack components_.
* [Stack Components](using-and-switching-stacks.md#stack-components): Configuration of MLOps tools, which come in different _categories_ and _flavors_.
* [Flavors](using-and-switching-stacks.md#stack-component-flavors): Represent a concrete implementation of a stack component.

Let's discuss each in further detail:

## Stack

In ZenML, a **Stack** represents a set of configurations for your MLOps tools and infrastructure. For instance, you might want to:

* Orchestrate your ML workflows with [Kubeflow](broken-reference),
* Save ML artifacts in an [Amazon S3](broken-reference) bucket,
* Track your experiments with [Weights & Biases](broken-reference),
* Deploy models on Kubernetes with [Seldon](broken-reference) or [KServe](broken-reference),

In the illustration, you see one user register two stacks, the `Local Stack` and a `Production Stack`. These stacks can be shared with other people easily - something we'll dig into more [later](broken-reference).

![Running your pipeline in the cloud](broken-reference)

Any such combination of tools and infrastructure can be registered as a separate stack in ZenML. Since ZenML code is tooling-independent, you can switch between stacks with a single command and then automatically execute your ML workflows on the desired stack without having to modify your code.

### The Default Stack

By default, every ZenML project that you create already come with an initial active `default` stack. If you followed the code examples in the [Steps and Pipelines](broken-reference) section, then you have already used this stack implicitly to run all of your pipelines.

This stack features two stack components:

* A [Local Orchestrator](broken-reference),
* A [Local Artifact Store](broken-reference),

Speaking of stack components...

## Stack Components

In ZenML, each MLOps tool is associated with a specific **Stack Component**, which is responsible for one specific task of your ML workflow. All stack components are grouped into [categories](broken-reference).

For instance, each ZenML stack (e.g. the default stack above) includes an _Orchestrator_ which is responsible for the execution of the steps within your pipeline and an _Artifact Store_ which is responsible for storing the artifacts generated by your pipelines.

{% hint style="info" %}
Check out the [Categories of MLOps Tools](broken-reference) page for a detailed overview of available stack components in ZenML.
{% endhint %}

### Orchestrator

The [Orchestrator](broken-reference) is the component that defines how and where each pipeline step is executed when calling `pipeline.run()`. By [default](broken-reference), all runs are executed locally, but by configuring a different orchestrator you can, e.g., automatically execute your ML workflows on [Kubeflow](broken-reference) instead.

### Artifact Stores

Under the hood, all the artifacts in our ML pipeline are automatically stored in an [Artifact Store](broken-reference). By [default](broken-reference), this is simply a place in your local file system, but we could also configure ZenML to store this data in a cloud bucket like [Amazon S3](broken-reference) or any other place instead.

You can see all supported stack component types in a single table view [here](broken-reference)

{% hint style="info" %}
Every stack can usually contain one stack component category of each type, e.g., one `Orchestrator`, one `Artifact Store`, etc, but in some cases, you can have more than one stack component category in one stack (e.g. in the case of having two `Step Operators` in your stack). We will discuss this in later chapters.
{% endhint %}

## Stack Component Flavors

The specific tool you are using is called a **Flavor** of the stack component. E.g., _Kubeflow_ is a flavor of the _Orchestrator_ stack component category.

Out-of-the-box, ZenML already comes with a wide variety of flavors, which are either built-in or enabled through the installation of specific [Integrations](broken-reference).

## Listing Stacks, Stack Components, and Flavors

{% hint style="info" %}
Our CLI features a wide variety of commands that let you manage and use your stacks. If you would like to learn more, please run: "`zenml stack --help`" or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

You can see a list of all your _registered_ stacks with the following command:

```shell
zenml stack list
```

Similarly, you can see all _registered_ stack components of a specific type using `zenml <STACK_COMPONENT_CATEGORY> list`, e.g.:

```shell
zenml orchestrator list
```

In order to see all the _available_ flavors for a specific stack component use `zenml <STACK_COMPONENT_CATEGORY> flavor list`, e.g.:

```shell
zenml orchestrator flavor list
```

You can also see details of configuration parameters available for a flavor with `zenml <STACK_COMPONENT_CATEGORY> flavor describe <FLAVOR>`, e.g.:

```shell
zenml orchestrator flavor describe kubeflow
```

You can combine various MLOps tools into a ZenML stack as follows:

1. [Register a stack component](using-and-switching-stacks.md#registering-stack-components) to configure each tool using `zenml <STACK_COMPONENT> register`.
2. [Register a stack](using-and-switching-stacks.md#registering-a-stack) to bring a particular combination of stack components together using `zenml stack register`.
3. [Register a stack flavor](broken-reference) to add a new tool to the ZenML flavor registry, if the tool you are looking for is not supported out-of-the-box, or if you want to modify standard behavior of standard flavors.

In this guide, we will learn about the first two, while the last is a slightly [advanced topic covered later](broken-reference).

## Registering Stack Components

First, you need to create a new instance of the respective stack component with the desired flavor using `zenml <STACK_COMPONENT> register <NAME> --flavor=<FLAVOR>`. Most flavors require further parameters that you can pass as additional arguments `--param=value`, similar to how we passed the flavor.

E.g., to register a _local_ artifact store, we could use the following command:

```shell
zenml artifact-store register <ARTIFACT_STORE_NAME> \
    --flavor=local \
    --path=/path/to/your/store
```

In case you do not know all the available parameters, you can also use the interactive mode to register stack components. This will then walk you through each parameter (to skip just press ENTER):

```shell
zenml artifact-store register <ARTIFACT_STORE_NAME> \
    --flavor=local -i
```

Or you could simply describe the flavor to give a list of configuration available:

```shell
zenml artifact-store flavor describe local
```

After registering, you should be able to see the new artifact store in the list of registered artifact stores, which you can access using the following command:

```shell
zenml artifact-store list
```

Or you can register on the dashboard directly:

![Orchestrator list](broken-reference)

![Registering stack components](broken-reference)

{% hint style="info" %}
Our CLI features a wide variety of commands that let you manage and use your stack components and flavors. If you would like to learn more, please run `zenml <STACK_COMPONENT> --help` or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

## Registering a Stack

After registering each tool as the respective stack components, you can combine all of them into one stack using the `zenml stack register` command:

```shell
zenml stack register <STACK_NAME> \
    --orchestrator <ORCHESTRATOR_NAME> \
    --artifact-store <ARTIFACT_STORE_NAME> \
    ...
```

{% hint style="info" %}
You can use `zenml stack register --help` to see a list of all possible arguments to the `zenml stack register` command, including a list of which option to use for which stack component.
{% endhint %}

Alternatively, you can see and register stacks on the dashboard as well:

![Stack list](broken-reference)

![Registering stack](broken-reference)

## Activating a Stack

Finally, to start using the stack you just registered, set it as active:

```shell
zenml stack set <STACK_NAME>
```

Now all your code is automatically executed using this stack.

## Changing Stacks

If you have multiple stacks configured, you can switch between them using the `zenml stack set` command, similar to how you [activate a stack](using-and-switching-stacks.md#activating-a-stack).

## Accessing the Active Stack in Python

The following code snippet shows how you can retrieve or modify information of your active stack and stack components in Python:

```python
from zenml.client import Client

client = Client()
active_stack = client.active_stack
print(active_stack.name)
print(active_stack.orchestrator.name)
print(active_stack.artifact_store.name)
print(active_stack.artifact_store.path)
```

## Unregistering Stacks

To unregister (delete) a stack and all of its components, run

```shell
zenml stack delete <STACK_NAME>
```

to delete the stack itself, followed by

```shell
zenml <STACK_COMPONENT> delete <STACK_COMPONENT_NAME>
```

to delete each of the individual stack components.

{% hint style="warning" %}
If you provisioned infrastructure related to the stack, make sure to deprovision it using `zenml stack down --force` before unregistering the stack. See the [Managing Stack States](broken-reference) section for more details.
{% endhint %}
