---
description: What are stacks and repositories in ZenML
---

# Things to change

- Now they they have listed things, we should ask them register a new orchestrator stack component of flavor airflow and build a stack with it. 
- Then we should run a pipeline and show them on the UI what happened

# Older content (Page 1)

Machine learning in production is not just about designing and training models. It is a fractured space consisting of a wide variety of tasks ranging from experiment tracking to orchestration, from model deployment to monitoring, from drift detection to feature stores and much, much more than that. Even though there are already some seemingly well-established solutions for these tasks, it can become increasingly difficult to establish a running production system in a reliable and modular manner once all these solutions are brought together.

This is a problem which is especially critical when switching from a research setting to a production setting. 
Due to a lack of standards, the time and resources invested in proof of concepts frequently go completely to waste, because the initial system can not easily be transferred to a production-grade setting.

At **ZenML**, we believe that this is one of the most important and challenging problems in the field of MLOps, and it can be solved with a set of standards and well-structured abstractions. Owing to the nature of MLOps, it is essential that these abstractions not only cover concepts such as pipelines and steps but also the infrastructure elements on which the pipelines run.

Taking this into consideration, ZenML provides additional abstractions that
help you simplify infrastructure configuration and management:
- [Stacks](./stack.md) represent different configurations of MLOps tools and 
infrastructure; Each stack consists of multiple
**Stack Components** that each come in several **Flavors**,
- [Repositories](./repository.md) link stacks to the pipeline and step code of 
your ML projects.

# Older content (Page 2)

In ZenML, a **Stack** represents a set of configurations for your MLOps tools
and infrastructure. For instance, you might want to:

- Orchestrate your ML workflows with [Kubeflow](../../component-gallery/orchestrators/kubeflow.md),
- Save ML artifacts in an [Amazon S3](../../component-gallery/artifact-stores/amazon-s3.md) bucket,
- Track ML metadata in a managed [MySQL](../../component-gallery/metadata-stores/mysql.md) database,
- Track your experiments with [Weights & Biases](../../component-gallery/experiment-trackers/wandb.md),
- Deploy models on Kubernetes with [Seldon](../../component-gallery/model-deployers/seldon.md) or [KServe](../../component-gallery/model-deployers/kserve.md),

Any such combination of tools and infrastructure can be registered as a 
separate stack in ZenML. Since ZenML code is tooling-independent, you can 
switch between stacks with a single command and then automatically execute your
ML workflows on the desired stack without having to modify your code.

## Stack Components

In ZenML, each MLOps tool is associated to a specific **Stack Component**,
which is responsible for one specific task of your ML workflow. 

For instance, each ZenML stack includes an *Orchestrator* which is responsible
for the execution of the steps within your pipeline, an *Artifact Store* which
is responsible for storing the artifacts generated by your pipelines, and a
*Metadata Store* that tracks what artifact was produced or consumed by which
pipeline steps.

{% hint style="info" %}
Check out the [Categories of MLOps Tools](../../component-gallery/categories.md)
page for a detailed overview of available stack components in ZenML.
{% endhint %}

##  Orchestrator, Artifact Store, and Metadata Store

As mentioned above, orchestrators, artifact stores, and metadata stores are the
three components that need to be in every ZenML stack. The interaction of these
three components enables a lot of the magic of ZenML, such as data and model
versioning, automated artifact lineage tracking, automated caching, and more.

![Orchestrators, Artifact Store, and Metadata Store](../../assets/localstack.png)

### Orchestrator

The [Orchestrator](../../component-gallery/orchestrators/orchestrators.md) is the 
component that defines how and where each pipeline step is executed when
calling `pipeline.run()`. By [default](../../component-gallery/orchestrators/local.md),
all runs are executed locally, but by configuring a different orchestrator you
can, e.g., automatically execute your ML workflows on 
[Kubeflow](../../component-gallery/orchestrators/kubeflow.md) instead.

### Artifact Stores

Under the hood, all the artifacts in our ML pipeline are automatically stored
in an [Artifact Store](../../component-gallery/artifact-stores/artifact-stores.md).
By [default](../../component-gallery/artifact-stores/local.md), this is simply a
place in your local file system, but we could also configure ZenML to store
this data in a cloud bucket like [Amazon S3](../../component-gallery/artifact-stores/amazon-s3.md) 
or any other place instead.

### Metadata Stores

In addition to the artifact itself, ZenML automatically stores metadata about
each pipeline run in a [Metadata Store](../../component-gallery/metadata-stores/metadata-stores.md). 
By default, this uses an [SQLite](../../component-gallery/metadata-stores/sqlite.md)
database on your local machine, but we could again switch it out for another
storage type, such as a [MySQL](../../component-gallery/metadata-stores/mysql.md)
database deployed in the cloud.

## Stack Component Flavors

The specific tool you are using is called a **Flavor** of the stack component. 
E.g., *Kubeflow* is a flavor of the *Orchestrator* stack component.

Out-of-the-box, ZenML already comes with a wide variety of flavors, which are
either built-in or enabled through the installation of specific
[Integrations](../../component-gallery/integrations.md).

## The default Stack

By default, ZenML itself and every [Repository](#repositories) that you create
already come with an initial active `default` stack, which features:
- A [local orchestrator](../../component-gallery/orchestrators/local.md),
- A [local artifact store](../../component-gallery/artifact-stores/local.md),
- A [local SQLite metadata store](../../component-gallery/metadata-stores/sqlite.md).

If you followed the code examples in the 
[Steps and Pipelines](../steps-pipelines/steps-and-pipelines.md) section, then you have already
used this stack implicitly to run all of your pipelines.

## Listing Stacks, Stack Components, and Flavors

You can see a list of all your *registered* stacks with the following command:

```shell
zenml stack list
```

Similarly, you can see all *registered* stack components of a specific type using:

```shell
zenml <STACK_COMPONENT> list
```

In order to see all the *available* flavors for a specific stack component, use:

```shell
zenml <STACK_COMPONENT> flavor list
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you manage and use your stacks.
If you would like to learn more, please run: "`zenml stack --help`"
or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

## Registering New Stacks

You can combine various MLOps tools into a ZenML stack as follows:

1. [Register a stack component](#registering-stack-components) for each tool 
using `zenml <STACK_COMPONENT> register`,
2. [Register a stack](#registering-a-stack) to bring all tools together using
`zenml stack register`,
3. [Activate the stack](#activating-a-stack) using `zenml stack set`. Now all
your code is automatically executed using the desired tools / infrastructure.

### Registering Stack Components

First, you need to create a new instance of the respective stack component
with the desired flavor using `zenml <STACK_COMPONENT> register <NAME> --flavor=<FLAVOR>`. 
Most flavors require further parameters that you can pass as additional
arguments `--param=value`, similar to how we passed the flavor.

E.g., to register a *local* artifact store, we could use the following command:

```shell
zenml artifact-store register <ARTIFACT_STORE_NAME> \
    --flavor=local \
    --path=/path/to/your/store
```

In case you do not know all the available parameters, you can also use the 
interactive mode to register stack components. This will then walk you through 
each parameter (to skip just press ENTER):

```shell
zenml artifact-store register <ARTIFACT_STORE_NAME> \
    --flavor=local -i
```


Afterwards, you should be able to see the new artifact store in the
list of registered artifact stores, which you can access using the following command:

```shell
zenml artifact-store list
```

{% hint style="info" %}
Our CLI features a wide variety of commands that let you manage and use your
stack components and flavors. If you would like to learn more, please run
`zenml <STACK_COMPONENT> --help` or visit [our CLI docs](https://apidocs.zenml.io/latest/cli/).
{% endhint %}

### Registering a Stack

After registering each tool as the respective stack component, you can combine
all of them into one stack using the `zenml stack register` command:

```shell
zenml stack register <STACK_NAME> \
    --orchestrator <ORCHESTRATOR_NAME> \
    --artifact-store <ARTIFACT_STORE_NAME> \
    --metadata-store <METADATA_STORE_NAME> \
    ...
```

{% hint style="info" %}
You can use `zenml stack register --help` to see a list of all possible 
arguments to the `zenml stack register` command, including a list of which 
option to use for which stack component.
{% endhint %}

### Activating a Stack

Finally, to start using the stack you just registered, set it as active:

```shell
zenml stack set <STACK_NAME>
```
Now all your code is automatically executed using this stack.

{% hint style="info" %}
Some advanced stack component flavors might require connecting to remote 
infrastructure components prior to running code on the stack. This can be done
using `zenml stack up`. See the [Managing Stack States](../advanced-usage/stack-state-management.md)
section for more details.
{% endhint %}

## Changing Stacks

If you have multiple stacks configured, you can switch between them using the
`zenml stack set` command, similar to how you [activate a stack](#activating-a-stack).

## Unregistering Stacks

To unregister (delete) a stack and all of its components, run

```shell
zenml stack delete <STACK_NAME>
```

to delete the stack itself, followed by

```shell
zenml <STACK_COMPONENT> delete <STACK_COMPONENT_NAME>
```

to delete each of the individual stack components.

{% hint style="warning" %}
If you provisioned infrastructure related to the stack, make sure to
deprovision it using `zenml stack down --force` before unregistering the stack.
See the [Managing Stack States](../advanced-usage/stack-state-management.md) section for more details.
{% endhint %}

# Older content (page 2)

ZenML has two main locations where it stores information on the local machine.
These are the [Global Configuration](../../resources/global-config.md) and the 
_Repository_. The latter is also referred to as the _.zen folder_.

The ZenML **Repository** related to a pipeline run is the folder that contains 
all the files needed to execute the run, such as the respective Python scripts
and modules where the pipeline is defined, or other associated files.
The repository plays a double role in ZenML:

* It is used by ZenML to identify which files must be copied into Docker images 
in order to execute pipeline steps remotely, e.g., when orchestrating pipelines
with [Kubeflow](../../component-gallery/orchestrators/kubeflow.md).
* It defines the local active [Stack](#stacks) that will be used when running
pipelines from the repository root or one of its sub-folders, as shown
[below](#setting-the-local-active-stack).

## Registering a Repository

You can register your current working directory as a ZenML
repository by running:

```bash
zenml init
```

This will create a `.zen` directory, which contains a single
`config.yaml` file that stores the local settings:

```yaml
active_project_name: null
active_stack_name: default
```

{% hint style="info" %}
It is recommended to use the `zenml init` command to initialize a ZenML
_Repository_ in the same location of your custom Python source tree where you
would normally point `PYTHONPATH`, especially if your Python code relies on a
hierarchy of modules spread out across multiple sub-folders.

ZenML CLI commands and ZenML code will display a warning if they are not running
in the context of a ZenML repository, e.g.:

```shell
stefan@aspyre2:/tmp$ zenml stack list
Unable to find ZenML repository in your current working directory (/tmp) or any parent directories. If you want to use an existing repository which is in a different location, set the environment variable 'ZENML_REPOSITORY_PATH'. If you want to create a new repository, run zenml init.
Running without an active repository root.
Using the default local database.
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```
{% endhint %}

## Setting the Local Active Stack

One of the most useful features of repositories is that you can configure a
different active stack for each of your projects. This is great if
you want to use ZenML for multiple projects on the same machine. Whenever you
create a new ML project, we recommend you run `zenml init` to create a separate
repository, then use it to define your stacks:

```bash
zenml init
zenml stack register ...
zenml stack set ...
```

If you do this, the correct stack will automatically get activated
whenever you change directory from one project to another in your terminal.

{% hint style="info" %}
Note that the stacks and stack components are still stored globally, even when
running from inside a ZenML repository. It is only the active stack setting
that can be configured locally.
{% endhint %}

### Detailed Example

<details>
<summary>Detailed usage example of local stacks</summary>

The following example shows how the active stack can be configured locally for a
project without impacting the global settings:

```
/tmp/zenml$ zenml stack list
Unable to find ZenML repository in your current working directory (/tmp/zenml)
or any parent directories. If you want to use an existing repository which is in
a different location, set the environment variable 'ZENML_REPOSITORY_PATH'. If
you want to create a new repository, run zenml init.
Running without an active repository root.
Using the default local database.
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃        │ zenml      │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml init
ZenML repository initialized at /tmp/zenml.
The local active stack was initialized to 'default'. This local configuration will
only take effect when you're running ZenML from the initialized repository root,
or from a subdirectory. For more information on repositories and configurations,
please visit https://docs.zenml.io/developer-guide/stacks-repositories.


$ zenml stack list
Using the default local database.
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃        │ zenml      │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ zenml stack set zenml
Using the default local database.
Active repository stack set to: 'zenml'

/tmp/zenml$ zenml stack list
Using the default local database.
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃        │ default    │ default        │ default        │ default      ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ zenml      │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛

/tmp/zenml$ cd ..
/tmp$ zenml stack list
Unable to find ZenML repository in your current working directory (/tmp) or any
parent directories. If you want to use an existing repository which is in a
different location, set the environment variable 'ZENML_REPOSITORY_PATH'. If you
want to create a new repository, run zenml init.
Running without an active repository root.
Using the default local database.
┏━━━━━━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓
┃ ACTIVE │ STACK NAME │ ARTIFACT_STORE │ METADATA_STORE │ ORCHESTRATOR ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃   👉   │ default    │ default        │ default        │ default      ┃
┠────────┼────────────┼────────────────┼────────────────┼──────────────┨
┃        │ zenml      │ default        │ default        │ default      ┃
┗━━━━━━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛
```

</details>

## Using the Repository in Python

You can access your repository in Python using the `zenml.repository.Repository`
class:

```python
from zenml.repository import Repository


repo = Repository()
```

This allows you to perform various repository operations directly in Python, 
such as [Inspecting Finished Pipeline Runs](../steps-pipelines/inspecting-pipeline-runs.md) or
accessing and managing stacks, as shown below.

{% hint style="info" %}
To explore all possible operations that can be performed via the
`Repository`, please consult the API docs section on
[Repository](https://apidocs.zenml.io/latest/api_docs/repository/#zenml.repository.Repository).
{% endhint %}

### Accessing the Active Stack

The following code snippet shows how you can retrieve or modify information
of your active stack and stack components in Python:

```python
from zenml.repository import Repository


repo = Repository()
active_stack = repo.active_stack
print(active_stack.name)
print(active_stack.orchestrator.name)
print(active_stack.artifact_store.name)
print(active_stack.artifact_store.path)
print(active_stack.metadata_store.name)
print(active_stack.metadata_store.uri)
```

### Registering and Changing Stacks

In the following we use the repository to register a new ZenML stack called
`local` and set it as the active stack of the repository:

```python
from zenml.repository import Repository
from zenml.artifact_stores import LocalArtifactStore
from zenml.orchestrators import LocalOrchestrator
from zenml.stack import Stack


repo = Repository()

# Create a new orchestrator
orchestrator = LocalOrchestrator(name="local")

# Create a new artifact store
artifact_store = LocalArtifactStore(
    name="local",
    path="/tmp/zenml/artifacts",
)

# Create a new stack with the new components
stack = Stack(
    name="local",
    orchestrator=orchestrator,
    artifact_store=artifact_store,
)

# Register the new stack
repo.register_stack(stack)

# Set the stack as the active stack of the repository
repo.activate_stack(stack.name)
```

## Unregistering a Repository

To unregister a repository, delete the `.zen` directory in the
respective location, e.g., via 

```bash
rm -rf .zen
```